// (C) 2013-2015, Sergei Zaychenko, KNURE, Kharkiv, Ukraine

/*****************************************************************************/

#include <iostream>
    
/*****************************************************************************/


int main ()
{
    // Группа переменных для первого динамически растущего массива
    // Изначально выделяем блок для хранения 10 элементов, 0 занято
    int nAllocated1 = 10; 
    int nUsed1 = 0;
    int * pData1 = new int[ nAllocated1 ];

    // Аналогичная группа переменных для второго динамически растущего массива
    int nAllocated2 = 10;
    int nUsed2 = 0;
    int * pData2 = new int[ nAllocated2 ];

    // Цикл ввода первой последовательности
    while ( true )
    {
        // Вводим очередное число с клавиатуры
        int value;
        std::cin >> value;

        // Если число не является положительным, выходим из цикла
        if ( value <= 0 )
            break;

        // Введено положительное число. Необходимо разместить его в массиве.
        // Достиг ли массив пределов выделенного объема памяти?
        if ( nAllocated1 == nUsed1 )
        {
            // Предел объема хранения достигнут. Выделяем вдвое больший массив
            int newAllocated1 = nAllocated1 << 1;
            int * pTemp = new int[ newAllocated1 ];
            
            // Копируем данные из прежнего массива в новый
            memcpy( pTemp, pData1, sizeof( int ) * nUsed1 );

            // Освобождаем прежний блок
            delete[] pData1;

            // Подменяем указатель на блок и размер в массиве на новые
            pData1 = pTemp;
            nAllocated1 = newAllocated1;
        }

        // В данной точке места для хранения достаточно.
        // Помещаем новое данное в массив и увеличиваем счетчик хранящихся элементов
        pData1[ nUsed1++ ] = value;
    }

    // Цикл ввода второй последовательности
    while ( true )
    {
        // Вводим очередное число с клавиатуры
        int value;
        std::cin >> value;

        // Если число не является положительным, выходим из цикла
        if ( value <= 0 )
            break;

        // Введено положительное число. Необходимо разместить его в массиве.
        // Достиг ли массив пределов выделенного объема памяти?
        if ( nAllocated2 == nUsed2 )
        {
            // Предел объема хранения достигнут. Выделяем вдвое больший массив
            int newAllocated2 = nAllocated2 << 1;
            int * pTemp = new int[ newAllocated2 ];

            // Копируем данные из прежнего массива в новый
            memcpy( pTemp, pData2, sizeof( int ) * nUsed2 );
   
            // Освобождаем прежний блок
            delete[] pData2;
   
            // Подменяем указатель на блок и размер в массиве на новые
            pData2 = pTemp;
            nAllocated2 = newAllocated2;
        }

        // В данной точке места для хранения достаточно.
        // Помещаем новое данное в массив и увеличиваем счетчик хранящихся элементов
        pData2[ nUsed2++ ] = value;
    }

    // Суммируем элементы первой последовательности
    int sum1 = 0;
    for ( int i = 0; i < nUsed1; i++ )
        sum1 += pData1[ i ];

    // Суммируем элементы второй последовательности
    int sum2 = 0;
    for ( int i = 0; i < nUsed2; i++ )
        sum2 += pData2[ i ];

    // Сравниваем суммы и выводим результат
    if ( sum1 > sum2 )
        std::cout << "First sequence {" << sum1 <<
           "} has bigger sum than the second {" <<
           sum2 << "}" << std::endl;
    else if ( sum1 < sum2 )
        std::cout << "Second sequence {" << sum2 << 
            "} has bigger sum than the first {"  << 
            sum1 << "}" << std::endl;
    else
        std::cout << "Sequences have equal sum {" << sum1 << "}" << std::endl;

    // Освобождаем ресурсы обеих последовательностей
    delete[] pData1;
    delete[] pData2;
}


/*****************************************************************************/

